---
description: code structuring for basepack
alwaysApply: false
---
# Basepack Code Structure

## Project Organization

Basepack is a modular service utilities library. Each service is self-contained in its own directory under `src/`.

### Directory Structure

```
src/
├── index.ts                    # Main entry point - re-exports all services
└── email/                      # Email service module
    ├── index.ts                # Email module exports
    ├── types.ts                # Type definitions and interfaces
    ├── service.ts              # EmailService class
    ├── errors.ts               # Error classes (EmailError, EmailValidationError, etc.)
    ├── validation.ts           # Validation utilities
    ├── retry.ts                # Retry logic with exponential backoff
    └── adapters/               # Provider implementations
        ├── index.ts            # Adapter exports
        ├── ses.ts              # AWS SES adapter
        ├── sendgrid.ts         # SendGrid adapter
        ├── mailgun.ts          # Mailgun adapter
        ├── resend.ts           # Resend adapter
        ├── postmark.ts         # Postmark adapter
        └── smtp.ts             # SMTP adapter
```

### File Responsibilities

**Service Module Pattern** (applies to all services):

1. **`types.ts`** - Type definitions
   - All interfaces and types for the service
   - Configuration types for each provider
   - Type guards and utility types
   - Const assertions for enums

2. **`service.ts`** - Main service class
   - Public API for the service
   - Multi-provider orchestration
   - Failover logic
   - Provider factory method

3. **`errors.ts`** - Error handling
   - Service-specific error classes
   - Type guards for errors
   - Structured error information

4. **`validation.ts`** - Input validation
   - Validation functions
   - Validation rules
   - Error throwing on invalid input

5. **`retry.ts`** - Retry logic (if needed)
   - Exponential backoff implementation
   - Retryable error detection
   - Configurable retry options

6. **`adapters/`** - Provider implementations
   - Each provider in its own file
   - Implements `IProvider` interface
   - Uses dynamic imports for optional dependencies
   - Provider-specific error handling

### Adding New Services

When adding a new service (e.g., cache, storage):

```
src/
└── cache/                      # New service
    ├── index.ts                # Export service and types
    ├── types.ts                # ICacheProvider, CacheConfig, etc.
    ├── service.ts              # CacheService class
    ├── errors.ts               # CacheError, etc.
    └── adapters/
        ├── redis.ts            # Redis adapter
        ├── memcached.ts        # Memcached adapter
        └── memory.ts           # In-memory adapter
```

Then export from main [index.ts](mdc:src/index.ts):
```typescript
export * from './cache';
```

### Testing Structure

```
tests/
├── unit/                       # Unit tests (run in CI)
│   └── email/
│       ├── validation.test.ts
│       ├── errors.test.ts
│       ├── retry.test.ts
│       └── types.test.ts
└── integration/                # Integration tests (run locally)
    └── email/
        └── adapters/
            ├── ses.test.ts
            ├── sendgrid.test.ts
            └── ...
```

### Documentation Structure

```
docs/
└── email/
    └── README.md               # Complete email service documentation
```

Main [README.md](mdc:README.md) stays minimal and links to service-specific docs.

#### Documentation Organization Rules

**Common patterns and cross-cutting concerns go in the main README only:**

1. **Logging** - Main README has complete logging documentation
   - Service-specific docs: ❌ No logging sections
   - Users refer to main README to understand how to configure logging

2. **Error Handling** - If error patterns are similar across services
   - Main README: ✅ General error handling patterns
   - Service docs: Only service-specific error details

3. **Authentication/Configuration Patterns** - If pattern is consistent
   - Main README: ✅ Common configuration patterns
   - Service docs: Provider-specific configuration only

4. **Common Features** (validation, retry logic, health checks)
   - Main README: ✅ General concepts if applicable to multiple services
   - Service docs: Service-specific behavior and examples

**Service-specific documentation should include:**
- Provider setup guides and configuration
- Service-specific features and capabilities
- API reference for that service
- Examples unique to that service

**Example:**
```markdown
<!-- docs/email/README.md -->

## Configuration
[Service-specific provider configs...]

## Usage Examples
[Email-specific examples...]

## API Reference
[EmailService methods...]

<!-- No logging section - users see main README -->
```

**Benefits:**
- Single source of truth for common patterns
- Easier to maintain (update once, not N times)
- Clearer separation between common and service-specific concerns
- Reduces documentation bloat

### Build Output

```
dist/
├── index.js                    # ESM bundle
├── index.js.map                # ESM source map
├── index.cjs                   # CommonJS bundle
├── index.cjs.map               # CJS source map
├── index.d.ts                  # TypeScript definitions (ESM)
└── index.d.cts                 # TypeScript definitions (CJS)
```

## Key Principles

1. **Service Independence** - Each service is self-contained
2. **Adapter Pattern** - All providers implement a common interface
3. **Optional Dependencies** - Heavy dependencies are peer dependencies with dynamic imports
4. **Type Safety** - Discriminated unions for provider-specific configs
5. **Validation** - All inputs validated before processing
6. **Error Handling** - Structured errors with type guards
7. **Documentation** - JSDoc on all public APIs
# Basepack Code Structure

## Project Organization

Basepack is a modular service utilities library. Each service is self-contained in its own directory under `src/`.

### Directory Structure

```
src/
├── index.ts                    # Main entry point - re-exports all services
└── email/                      # Email service module
    ├── index.ts                # Email module exports
    ├── types.ts                # Type definitions and interfaces
    ├── service.ts              # EmailService class
    ├── errors.ts               # Error classes (EmailError, EmailValidationError, etc.)
    ├── validation.ts           # Validation utilities
    ├── retry.ts                # Retry logic with exponential backoff
    └── adapters/               # Provider implementations
        ├── index.ts            # Adapter exports
        ├── ses.ts              # AWS SES adapter
        ├── sendgrid.ts         # SendGrid adapter
        ├── mailgun.ts          # Mailgun adapter
        ├── resend.ts           # Resend adapter
        ├── postmark.ts         # Postmark adapter
        └── smtp.ts             # SMTP adapter
```

### File Responsibilities

**Service Module Pattern** (applies to all services):

1. **`types.ts`** - Type definitions
   - All interfaces and types for the service
   - Configuration types for each provider
   - Type guards and utility types
   - Const assertions for enums

2. **`service.ts`** - Main service class
   - Public API for the service
   - Multi-provider orchestration
   - Failover logic
   - Provider factory method

3. **`errors.ts`** - Error handling
   - Service-specific error classes
   - Type guards for errors
   - Structured error information

4. **`validation.ts`** - Input validation
   - Validation functions
   - Validation rules
   - Error throwing on invalid input

5. **`retry.ts`** - Retry logic (if needed)
   - Exponential backoff implementation
   - Retryable error detection
   - Configurable retry options

6. **`adapters/`** - Provider implementations
   - Each provider in its own file
   - Implements `IProvider` interface
   - Uses dynamic imports for optional dependencies
   - Provider-specific error handling

### Adding New Services

When adding a new service (e.g., cache, storage):

```
src/
└── cache/                      # New service
    ├── index.ts                # Export service and types
    ├── types.ts                # ICacheProvider, CacheConfig, etc.
    ├── service.ts              # CacheService class
    ├── errors.ts               # CacheError, etc.
    └── adapters/
        ├── redis.ts            # Redis adapter
        ├── memcached.ts        # Memcached adapter
        └── memory.ts           # In-memory adapter
```

Then export from main [index.ts](mdc:src/index.ts):
```typescript
export * from './cache';
```

### Testing Structure

```
tests/
├── unit/                       # Unit tests (run in CI)
│   └── email/
│       ├── validation.test.ts
│       ├── errors.test.ts
│       ├── retry.test.ts
│       └── types.test.ts
└── integration/                # Integration tests (run locally)
    └── email/
        └── adapters/
            ├── ses.test.ts
            ├── sendgrid.test.ts
            └── ...
```

### Documentation Structure

```
docs/
└── email/
    └── README.md               # Complete email service documentation
```

Main [README.md](mdc:README.md) stays minimal and links to service-specific docs.

#### Documentation Organization Rules

**Common patterns and cross-cutting concerns go in the main README only:**

1. **Logging** - Main README has complete logging documentation
   - Service-specific docs: ❌ No logging sections
   - Users refer to main README to understand how to configure logging

2. **Error Handling** - If error patterns are similar across services
   - Main README: ✅ General error handling patterns
   - Service docs: Only service-specific error details

3. **Authentication/Configuration Patterns** - If pattern is consistent
   - Main README: ✅ Common configuration patterns
   - Service docs: Provider-specific configuration only

4. **Common Features** (validation, retry logic, health checks)
   - Main README: ✅ General concepts if applicable to multiple services
   - Service docs: Service-specific behavior and examples

**Service-specific documentation should include:**
- Provider setup guides and configuration
- Service-specific features and capabilities
- API reference for that service
- Examples unique to that service

**Example:**
```markdown
<!-- docs/email/README.md -->

## Configuration
[Service-specific provider configs...]

## Usage Examples
[Email-specific examples...]

## API Reference
[EmailService methods...]

<!-- No logging section - users see main README -->
```

**Benefits:**
- Single source of truth for common patterns
- Easier to maintain (update once, not N times)
- Clearer separation between common and service-specific concerns
- Reduces documentation bloat

### Build Output

```
dist/
├── index.js                    # ESM bundle
├── index.js.map                # ESM source map
├── index.cjs                   # CommonJS bundle
├── index.cjs.map               # CJS source map
├── index.d.ts                  # TypeScript definitions (ESM)
└── index.d.cts                 # TypeScript definitions (CJS)
```

## Key Principles

1. **Service Independence** - Each service is self-contained
2. **Adapter Pattern** - All providers implement a common interface
3. **Optional Dependencies** - Heavy dependencies are peer dependencies with dynamic imports
4. **Type Safety** - Discriminated unions for provider-specific configs
5. **Validation** - All inputs validated before processing
6. **Error Handling** - Structured errors with type guards
7. **Documentation** - JSDoc on all public APIs
